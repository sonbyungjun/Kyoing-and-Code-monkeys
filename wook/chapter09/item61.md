# 박싱된 기본 타입보다는 기본 타입을 사옹하라

## 핵심 요약

자바의 데이터타입은 크게 두 가지로 나눌 수 있음.

1. `int`, `double`, `boolean`과 같은 기본타

1. `String`, `List` 같은 참조타입.

1. 각각의 기본 타입에 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 함. (Wrapper Class)

> 오토박싱과, 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만, 차이가 사라지는 것은 아님.

### 박싱과 기본타입의 차이

* 기본타입은 값만 가지고 있으나, 박싱된 기본타입은 값에 더해 식별성(identity)이란 속성을 갖는다.

  > 박싱된 기본타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.

* 기본타입의 값은 언제나 유효하지만, 박싱된 기본타입은 유효하지 않은 값, 즉 `null`을 가질 수 있다.

* 기본타입이 박싱된 기본타입보다 시간과 메모리 사용면에서 더 효율적이다.

### 박싱 타입 사용의 주의

* 잘못 구현된 compare

  ```java
  Comparator<Integer> naturalOrder =
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
  ```

* 결함

  `naturalOrder.compare(new Integer(42), new Integer(42))`의 값을 출력해보면, 두 인스턴의 값이 같으므로 0을 출력해야 하지만, 실제로는 1을 출력함.

* 원인

  첫 번째 검사 `(i < j)`는 잘 작동함. i와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본 타입 값으로 변환된다. 하지만, 두 번째 검사 `(i == j)`에서 객체 참조의 식별성 검사를 하게 된다.
  그래서 결함이 발생함.

  > 박싱된 기본 타입에 `==` 연산자를 사용하면 오류가 일어난다.

* 문제를 수정한 compare

  ```java
  Comparator<Integer> naturalOrder =
    (iBoxed, jBoxed) -> {
      int i = iBoxed, j = jBoxed; // 오토박싱
      return i < j ? -1 : (i == j ? 0 : 1);
    }
  ```

## 핵심 정리

기본타입과 박싱된 기본타입 중 하나를 선택해야 한다면 가능하면 기본타입을 사용하라. 박싱된 기본타입을 써야 한다면 주의를 기울여야함. 박싱된 기본타입으로 == 연산자 비교를 하면 식별성 비교가 이뤄지는데, 이는 우리가 원하는게 아닐 가능성이 크다. 또 언박싱 과정에서 NullPointerException을 던질 수 있다. 기본타입을 박싱하는 작업은 필요없는 객체를 생성하는 부작용이 나올수 있다.